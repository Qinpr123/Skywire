<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>钢丝行者 - 平衡挑战</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="bgBlur"></div>
    <div id="gameContainer" data-design-width="832" data-design-height="1480">
        <canvas id="gameCanvas" width="832" height="1480"></canvas>
        <div id="gameUI">
            <div>距离: <span id="distance">0</span>m</div>
            <div>摆幅: <span id="sway">0</span>°</div>
            <div>风力: <span id="wind">0</span></div>
            <div>最高分: <span id="highScore">0</span>m</div>
            <div id="audioControls">
                <button id="muteBtn" title="静音/取消静音">🔊</button>
                <input type="range" id="volumeSlider" min="0" max="100" value="30" title="音量控制">
            </div>
        </div>
        <div id="instructions">
            <div>← → 控制平衡</div>
            <div>Z 伸长平衡杆</div>
            <div>X 缩短平衡杆</div>
            <div>保持摆幅 < 60°</div>
            <div>按空格键开始</div>
        </div>
        
        <div id="powerUpLegend">
            <div style="color: #000000; font-weight: bold;">⚫ 黑色气球 - 爆炸</div>
            <div style="color: #FF0000; font-weight: bold;">🔴 红色气球 - 加速</div>
            <div style="color: #00FF00; font-weight: bold;">🟢 绿色气球 - 平衡</div>
            <div style="color: #0080FF; font-weight: bold;">🔵 蓝色气球 - 减速</div>
            <div style="color: #FFFF00; font-weight: bold;">🟡 黄色气球 - 失衡</div>
        </div>
        <div id="startScreen">
            <h1>钢丝行者</h1>
            <p>保持平衡，走得更远！</p>
            <p>使用 ← → 键控制平衡</p>
            <p>按空格键开始游戏</p>
        </div>
        <div id="gameOver">
            <h2>游戏结束！</h2>
            <p>你走了 <span id="finalDistance">0</span> 米</p>
            <button id="restartBtn">重新开始</button>
        </div>
    </div>

    <script src="main.js"></script>
    <script>
        class TightropeGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                // 游戏状态
                this.gameRunning = false;
                this.distance = 0;
                this.speed = 0.083; // 1秒5米，60fps下每帧约0.083米
                this.score = 0;
                this.highScore = localStorage.getItem('tightropeHighScore') || 0;
                this.gameStarted = false;
                
                // 主角属性
                this.player = {
                    x: this.width / 2,
                    y: this.height / 2,
                    sway: 0, // 摆幅角度
                    swaySpeed: 0, // 摆幅速度
                    size: 40
                };
                
                // 钢丝
                this.tightrope = {
                    x: this.width / 2,
                    thickness: 6
                };
                
                // 风力系统
                this.wind = {
                    force: 0,
                    direction: 1, // 1 或 -1
                    changeTimer: 0,
                    changeInterval: 60 // 帧数
                };
                
                // 背景
                this.background = {
                    offset: 0,
                    speed: 1
                };
                
                // 粒子系统
                this.particles = [];
                
                // 田园风景系统
                this.landscape = [];
                this.landscapeSpeed = this.speed * 2; // 背景滚动速度提升两倍
                this.landscapeSpawnTimer = 0;
                this.landscapeSpawnInterval = 200; // 帧数，降低生成频率
                
                // 云朵系统
                this.clouds = [];
                this.cloudSpawnTimer = 0;
                this.cloudSpawnInterval = 200; // 帧数
                
                // 道具系统
                this.powerUps = [];
                this.powerUpSpawnTimer = 0;
                this.powerUpSpawnInterval = 20; // 帧数，0.3秒生成一个
                this.activePowerUps = []; // 当前激活的道具
                
                // 平衡杆系统
                this.balanceRod = {
                    length: 60, // 默认长度
                    minLength: 30,
                    maxLength: 120,
                    extendSpeed: 2
                };
                
                // 控制
                this.keys = {};
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.gameLoop();
            }
            
            setupEventListeners() {
                // 键盘事件
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'Space' && !this.gameRunning) {
                        this.startGame();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // 重新开始按钮
                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.restartGame();
                });
            }
            
            startGame() {
                this.gameRunning = true;
                this.gameStarted = true;
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('gameOver').style.display = 'none';
                this.resetGame();
                this.initializeLandscape(); // 初始化田园风景
                this.initializeClouds(); // 初始化云朵
            }
            
            restartGame() {
                this.gameRunning = true;
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('gameOver').style.display = 'none';
                this.resetGame();
                this.initializeLandscape(); // 初始化田园风景
                this.initializeClouds(); // 初始化云朵
            }
            
            resetGame() {
                this.distance = 0;
                this.score = 0;
                this.player.x = this.width / 2;
                this.player.y = this.height / 2;
                this.player.sway = 0;
                this.player.swaySpeed = 0;
                this.wind.force = 0;
                this.wind.direction = 1;
                this.wind.changeTimer = 0;
                this.background.offset = 0;
                this.landscape = [];
                this.landscapeSpawnTimer = 0;
                this.clouds = [];
                this.cloudSpawnTimer = 0;
                this.powerUps = [];
                this.powerUpSpawnTimer = 0;
                this.activePowerUps = [];
                this.balanceRod.length = 60;
            }
            
            update() {
                if (!this.gameRunning) return;
                
                // 更新距离和分数
                this.distance += this.speed;
                this.score = Math.floor(this.distance);
                
                // 更新风力
                this.updateWind();
                
                // 更新玩家平衡
                this.updatePlayerBalance();
                
                // 更新背景
                this.updateBackground();
                
                // 更新粒子
                this.updateParticles();
                
                // 更新田园风景
                this.updateLandscape();
                
                // 更新云朵
                this.updateClouds();
                
                // 更新道具
                this.updatePowerUps();
                
                // 更新平衡杆
                this.updateBalanceRod();
                
                // 检查失败条件
                this.checkGameOver();
                
                // 更新UI
                this.updateUI();
            }
            
            updateWind() {
                this.wind.changeTimer++;
                if (this.wind.changeTimer >= this.wind.changeInterval) {
                    this.wind.direction *= -1;
                    this.wind.force = (Math.random() - 0.5) * 0.3;
                    this.wind.changeTimer = 0;
                    this.wind.changeInterval = 30 + Math.random() * 60;
                }
                
                // 风力逐渐变化
                this.wind.force += (Math.random() - 0.5) * 0.02;
                this.wind.force = Math.max(-0.5, Math.min(0.5, this.wind.force));
            }
            
            updatePlayerBalance() {
                // 检查是否有平衡增强道具且免疫键盘输入
                let isImmuneToInput = false;
                let isBalanceRestore = false;
                for (let powerUp of this.activePowerUps) {
                    if (powerUp.type === 'balance' && powerUp.immuneToInput) {
                        isImmuneToInput = true;
                        if (powerUp.balanceRestore) {
                            isBalanceRestore = true;
                        }
                        break;
                    }
                }
                
                // 如果处于平衡恢复状态，保持平衡
                if (isBalanceRestore) {
                    this.player.sway = 0; // 强制保持平衡
                    this.player.swaySpeed = 0; // 停止摆荡
                    return; // 直接返回，不处理其他力
                }
                
                // 风力影响（缩小两倍）
                let windEffect = this.wind.force * this.wind.direction * 0.5; // 从1缩小到0.5
                
                // 玩家控制（缩小两倍，且可能被免疫）
                let controlForce = 0;
                if (!isImmuneToInput) { // 只有在不免疫键盘输入时才响应
                    if (this.keys['ArrowLeft']) {
                        controlForce = -0.075; // 从-0.15缩小到-0.075
                    }
                    if (this.keys['ArrowRight']) {
                        controlForce = 0.075; // 从0.15缩小到0.075
                    }
                }
                
                // 计算总力
                let totalForce = windEffect + controlForce;
                
                // 更新摆幅速度
                this.player.swaySpeed += totalForce;
                
                // 应用平衡道具效果
                let damping = 0.95; // 默认阻尼
                for (let powerUp of this.activePowerUps) {
                    if (powerUp.type === 'balance') {
                        damping = 0.98; // 增强阻尼，减少摆荡
                    } else if (powerUp.type === 'unbalance') {
                        damping = 0.90; // 减少阻尼，增加摆荡
                    }
                }
                this.player.swaySpeed *= damping;
                
                // 更新摆幅
                this.player.sway += this.player.swaySpeed;
                
                // 限制摆幅范围
                this.player.sway = Math.max(-90, Math.min(90, this.player.sway));
                
                // 更新玩家位置（以脚为圆心旋转）
                this.player.x = this.tightrope.x;
                this.player.y = this.height / 2;
            }
            
            updateBackground() {
                this.background.offset += this.background.speed;
                if (this.background.offset >= this.height) {
                    this.background.offset = 0;
                }
            }
            
            updateParticles() {
                // 添加新粒子
                if (Math.random() < 0.3) {
                    this.particles.push({
                        x: Math.random() * this.width,
                        y: this.height + 10,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -Math.random() * 3 - 1,
                        life: 1.0,
                        decay: 0.01,
                        size: Math.random() * 3 + 1
                    });
                }
                
                // 更新现有粒子
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life -= particle.decay;
                    
                    if (particle.life <= 0 || particle.y < -10) {
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            updateLandscape() {
                // 同步风景滚动速度与人物速度
                let baseSpeed = this.speed * 10; // 背景移动速度为人物速度的5倍
                
                // 检查是否有速度提升道具，如果有则再增加2倍
                for (let powerUp of this.activePowerUps) {
                    if (powerUp.type === 'speed') {
                        baseSpeed *= 3; // 加速时背景建筑移速增加2倍
                        break;
                    }
                }
                
                this.landscapeSpeed = baseSpeed;
                
                // 生成新风景元素
                this.landscapeSpawnTimer++;
                if (this.landscapeSpawnTimer >= this.landscapeSpawnInterval) {
                    this.spawnLandscapeElement();
                    this.landscapeSpawnTimer = 0;
                    this.landscapeSpawnInterval = 30 + Math.random() * 50; // 更频繁生成，确保连续图案
                }
                
                // 更新现有风景元素位置
                for (let i = this.landscape.length - 1; i >= 0; i--) {
                    const element = this.landscape[i];
                    element.y += this.landscapeSpeed;
                    
                    // 移除超出屏幕的元素
                    if (element.y > this.height + 100) {
                        this.landscape.splice(i, 1);
                    }
                }
            }
            
            updateClouds() {
                // 生成新云朵
                this.cloudSpawnTimer++;
                if (this.cloudSpawnTimer >= this.cloudSpawnInterval) {
                    this.spawnCloud();
                    this.cloudSpawnTimer = 0;
                    this.cloudSpawnInterval = 150 + Math.random() * 200; // 随机间隔
                }
                
                // 更新现有云朵位置（根据风力）
                for (let i = this.clouds.length - 1; i >= 0; i--) {
                    const cloud = this.clouds[i];
                    
                    // 云朵根据风力移动
                    const windEffect = this.wind.force * this.wind.direction * 0.5; // 风力影响系数
                    cloud.x += windEffect;
                    
                    // 移除超出屏幕的云朵
                    if (cloud.x < -100 || cloud.x > this.width + 100) {
                        this.clouds.splice(i, 1);
                    }
                }
            }
            
            updatePowerUps() {
                // 生成新道具
                this.powerUpSpawnTimer++;
                if (this.powerUpSpawnTimer >= this.powerUpSpawnInterval) {
                    this.spawnPowerUp();
                    this.powerUpSpawnTimer = 0;
                    this.powerUpSpawnInterval = 60 + Math.random() * 60; // 1-2秒随机间隔
                }
                
                // 更新现有道具位置
                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    const powerUp = this.powerUps[i];
                    powerUp.y += 7; // 下落速度减缓到1/3
                    
                    // 检查是否被玩家收集
                    if (this.checkPowerUpCollision(powerUp)) {
                        this.collectPowerUp(powerUp);
                        this.powerUps.splice(i, 1);
                    }
                    // 移除超出屏幕的道具
                    else if (powerUp.y > this.height + 100) {
                        this.powerUps.splice(i, 1);
                    }
                }
                
                // 更新激活的道具
                for (let i = this.activePowerUps.length - 1; i >= 0; i--) {
                    const powerUp = this.activePowerUps[i];
                    powerUp.duration--;
                    
                    if (powerUp.duration <= 0) {
                        this.deactivatePowerUp(powerUp);
                        this.activePowerUps.splice(i, 1);
                    }
                }
            }
            
            updateBalanceRod() {
                // 平衡杆伸长缩短控制
                if (this.keys['KeyZ'] || this.keys['KeyX']) {
                    if (this.keys['KeyZ']) {
                        // Z键伸长
                        this.balanceRod.length = Math.min(this.balanceRod.maxLength, 
                            this.balanceRod.length + this.balanceRod.extendSpeed);
                    }
                    if (this.keys['KeyX']) {
                        // X键缩短
                        this.balanceRod.length = Math.max(this.balanceRod.minLength, 
                            this.balanceRod.length - this.balanceRod.extendSpeed);
                    }
                }
            }
            
            spawnLandscapeElement() {
                const elementTypes = ['tree', 'farmhouse']; // 只保留树木和房屋
                const elementType = elementTypes[Math.floor(Math.random() * elementTypes.length)];
                const rowY = -200; // 从更上方开始
                
                // 随机选择左侧或右侧，但远离钢丝
                const side = Math.random() < 0.5 ? 'left' : 'right';
                let x;
                
                if (side === 'left') {
                    // 左侧边沿，远离钢丝，避免重叠
                    x = 20 + Math.random() * 60; // 缩小范围避免重叠
                } else {
                    // 右侧边沿，远离钢丝，避免重叠
                    x = this.width - 80 - Math.random() * 60; // 缩小范围避免重叠
                }
                
                // 检查是否与现有元素重叠
                const minDistance = 70; // 减少最小距离，让建筑更密集
                let canPlace = true;
                
                for (let existing of this.landscape) {
                    if (existing.side === side) {
                        const distance = Math.abs(existing.x - x);
                        if (distance < minDistance) {
                            canPlace = false;
                            break;
                        }
                    }
                }
                
                // 只有不重叠时才添加
                if (canPlace) {
                    this.landscape.push({
                        x: x,
                        y: rowY,
                        type: elementType,
                        side: side,
                        size: 60 + Math.random() * 120 // 放大3倍
                    });
                }
            }
            
            spawnCloud() {
                // 根据风向决定云朵生成位置
                const windDirection = this.wind.direction;
                let startX;
                
                if (windDirection > 0) {
                    // 风向右吹，云朵从左侧进入
                    startX = -100;
                } else {
                    // 风向左吹，云朵从右侧进入
                    startX = this.width + 100;
                }
                
                this.clouds.push({
                    x: startX,
                    y: 30 + Math.random() * 100, // 云朵高度随机
                    size: 15 + Math.random() * 20, // 云朵大小随机
                    opacity: 0.6 + Math.random() * 0.4 // 透明度随机
                });
            }
            
            spawnPowerUp() {
                // 减少爆炸出现频率，其他道具出现概率更高
                const types = ['speed', 'balance', 'slow', 'unbalance', 'speed', 'balance', 'slow', 'unbalance', 'explosion']; // 爆炸只有1/9的概率
                const type = types[Math.floor(Math.random() * types.length)];
                
                // 道具掉落范围：从平衡杆初始长度到平衡杆最长伸长长度
                const tightropeX = this.tightrope.x;
                const minDistance = this.balanceRod.minLength+10; // 平衡杆初始长度
                const maxDistance = this.balanceRod.maxLength; // 平衡杆最长伸长长度
                
                // 随机选择左侧或右侧
                const side = Math.random() < 0.5 ? -1 : 1;
                const distance = minDistance + Math.random() * (maxDistance - minDistance);
                const x = tightropeX + (side * distance);
                
                this.powerUps.push({
                    x: x,
                    y: -50, // 从屏幕上方开始
                    type: type,
                    size: 20,
                    collected: false
                });
            }
            
            checkPowerUpCollision(powerUp) {
                // 检查道具是否与平衡杆碰撞
                const playerX = this.tightrope.x;
                const playerY = this.height / 2;
                const rodLength = this.balanceRod.length;
                
                // 平衡杆的左右端点
                const rodLeft = playerX - rodLength;
                const rodRight = playerX + rodLength;
                
                // 检查道具是否在平衡杆范围内
                return powerUp.x >= rodLeft && powerUp.x <= rodRight && 
                       powerUp.y >= playerY - 20 && powerUp.y <= playerY + 20;
            }
            
            collectPowerUp(powerUp) {
                // 播放音效
                this.playSound(powerUp.type);
                
                // 显示道具效果
                this.showPowerUpEffect(powerUp);
                
                // 检查平衡道具是否会被其他道具影响
                if (this.hasActivePowerUp('balance') && (powerUp.type === 'unbalance' || powerUp.type === 'slow')) {
                    // 平衡道具遇到失衡或减速道具时立即失效
                    this.clearBalanceEffect();
                }
                
                // 激活新道具效果
                const activePowerUp = {
                    type: powerUp.type,
                    duration: powerUp.type === 'balance' ? 180 : 300, // 平衡3秒，其他5秒，60fps
                    originalValue: null
                };
                
                if (powerUp.type === 'explosion') {
                    // 爆炸道具 - 直接死亡
                    this.gameOver();
                    return;
                } else if (powerUp.type === 'speed') {
                    // 加速道具 - 可以叠加
                    if (this.hasActivePowerUp('speed')) {
                        // 如果已有加速效果，叠加效果
                        this.speed *= 2; // 再次提升2倍
                    } else {
                        // 首次获得加速效果
                        activePowerUp.originalValue = this.speed;
                        this.speed *= 2; // 速度提升2倍
                    }
                } else if (powerUp.type === 'balance') {
                    // 平衡增强道具 - 可以叠加
                    this.player.sway = 0; // 立即回到中心位置
                    this.player.swaySpeed = 0; // 停止摆荡
                    if (!this.hasActivePowerUp('balance')) {
                        // 首次获得平衡效果
                        activePowerUp.originalValue = 0.95; // 阻尼系数
                        activePowerUp.immuneToInput = true; // 标记为免疫键盘输入
                        activePowerUp.balanceRestore = true; // 标记为平衡恢复状态
                    } else {
                        // 叠加平衡效果，延长持续时间
                        const existingBalance = this.activePowerUps.find(p => p.type === 'balance');
                        existingBalance.duration = 180; // 重置持续时间为3秒
                    }
                } else if (powerUp.type === 'slow') {
                    // 减速道具 - 可以叠加
                    if (this.hasActivePowerUp('slow')) {
                        // 如果已有减速效果，叠加效果
                        this.speed *= 0.5; // 再次除以2
                    } else {
                        // 首次获得减速效果
                        activePowerUp.originalValue = this.speed;
                        this.speed *= 0.5; // 速度除以2
                    }
                } else if (powerUp.type === 'unbalance') {
                    // 破坏平衡道具 - 失衡效果，向气球下落方向旋转15度
                    const unbalanceOffset = powerUp.x > this.tightrope.x ? 15 : -15; // 根据气球位置决定旋转方向
                    this.player.sway += unbalanceOffset; // 向气球下落方向旋转15度
                    // 失衡道具也可以叠加，延长持续时间
                    if (this.hasActivePowerUp('unbalance')) {
                        const existingUnbalance = this.activePowerUps.find(p => p.type === 'unbalance');
                        existingUnbalance.duration = 300; // 重置持续时间为5秒
                        return; // 不创建新的activePowerUp
                    }
                }
                
                // 只有首次获得的道具才添加到activePowerUps
                if (!this.hasActivePowerUp(powerUp.type)) {
                    this.activePowerUps.push(activePowerUp);
                }
            }
            
            hasActivePowerUp(type) {
                // 检查是否有指定类型的激活道具
                return this.activePowerUps.some(powerUp => powerUp.type === type);
            }
            
            clearBalanceEffect() {
                // 清除平衡道具效果
                const balanceIndex = this.activePowerUps.findIndex(powerUp => powerUp.type === 'balance');
                if (balanceIndex !== -1) {
                    this.activePowerUps.splice(balanceIndex, 1);
                }
                // 恢复原始阻尼系数
                this.player.damping = 0.95;
            }
            
            clearAllPowerUpEffects() {
                // 清除所有现有道具效果，恢复原始状态
                for (let powerUp of this.activePowerUps) {
                    if (powerUp.type === 'speed' || powerUp.type === 'slow') {
                        this.speed = powerUp.originalValue;
                    }
                    // 其他效果会自动恢复
                }
                this.activePowerUps = []; // 清空所有激活的道具
            }
            
            deactivatePowerUp(powerUp) {
                // 取消道具效果
                if (powerUp.type === 'speed') {
                    // 对于叠加的加速效果，需要逐步恢复
                    this.speed = powerUp.originalValue;
                } else if (powerUp.type === 'balance') {
                    // 恢复原始阻尼
                } else if (powerUp.type === 'slow') {
                    // 对于叠加的减速效果，需要逐步恢复
                    this.speed = powerUp.originalValue;
                } else if (powerUp.type === 'unbalance') {
                    // 恢复原始阻尼
                }
            }
            
            playSound(type) {
                // 简单的音效模拟（使用Web Audio API）
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // 根据道具类型设置不同音效
                    if (type === 'speed' || type === 'balance') {
                        // 正面道具 - 高音
                        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    } else if (type === 'explosion') {
                        // 死亡道具 - 低音
                        oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    } else {
                        // 负面道具 - 中音
                        oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    }
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (e) {
                    // 音效播放失败时静默处理
                }
            }
            
            showPowerUpEffect(powerUp) {
                // 显示道具效果文字 - 加大两倍并显示在屏幕正中间人物下方
                const effectText = document.createElement('div');
                effectText.style.position = 'absolute';
                effectText.style.left = '50%';
                effectText.style.top = '60%'; // 人物下方
                effectText.style.transform = 'translateX(-50%)'; // 水平居中
                effectText.style.color = this.getPowerUpColor(powerUp.type);
                effectText.style.fontSize = '40px'; // 加大两倍（从20px到40px）
                effectText.style.fontWeight = 'bold';
                effectText.style.pointerEvents = 'none';
                effectText.style.zIndex = '1000';
                effectText.style.textAlign = 'center';
                effectText.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)'; // 添加阴影增强可读性
                effectText.textContent = this.getPowerUpText(powerUp.type);
                
                document.body.appendChild(effectText);
                
                // 动画效果
                let opacity = 1;
                let y = 60; // 从60%开始
                const animate = () => {
                    opacity -= 0.015; // 稍微慢一点的淡出
                    y -= 0.5; // 向上移动
                    effectText.style.opacity = opacity;
                    effectText.style.top = y + '%';
                    
                    if (opacity > 0) {
                        requestAnimationFrame(animate);
                    } else {
                        document.body.removeChild(effectText);
                    }
                };
                animate();
            }
            
            getPowerUpColor(type) {
                const colors = {
                    'speed': '#FF0000',      // 红色 - 好道具
                    'balance': '#FF0000',    // 红色 - 好道具
                    'explosion': '#000000',  // 黑色 - 坏道具
                    'rock': '#000000',       // 黑色 - 坏道具
                    'slow': '#000000',       // 黑色 - 坏道具
                    'unbalance': '#000000'   // 黑色 - 坏道具
                };
                return colors[type] || '#FFFFFF';
            }
            
            getPowerUpText(type) {
                const texts = {
                    'explosion': '爆炸!',
                    'speed': '速度提升!',
                    'balance': '平衡增强!',
                    'slow': '减速!',
                    'unbalance': '平衡破坏!'
                };
                return texts[type] || '未知道具';
            }
            
            initializeLandscape() {
                // 游戏开始时创建初始田园风景，确保画面中有元素
                const leftPositions = [30, 50, 70]; // 左侧固定位置，避免重叠
                const rightPositions = [730, 750, 770]; // 右侧固定位置，避免重叠
                
                // 创建画面中的初始元素
                for (let i = 0; i < 3; i++) {
                    const rowY = 100 + i * 150; // 从画面中开始
                    
                    // 左侧元素
                    const leftX = leftPositions[i];
                    const leftType = ['tree', 'farmhouse'][Math.floor(Math.random() * 2)];
                    this.landscape.push({
                        x: leftX,
                        y: rowY,
                        type: leftType,
                        side: 'left',
                        size: 60 + Math.random() * 120
                    });
                    
                    // 右侧元素
                    const rightX = rightPositions[i];
                    const rightType = ['tree', 'farmhouse'][Math.floor(Math.random() * 2)];
                    this.landscape.push({
                        x: rightX,
                        y: rowY,
                        type: rightType,
                        side: 'right',
                        size: 60 + Math.random() * 120
                    });
                }
                
                // 创建画面上方的元素
                for (let i = 0; i < 5; i++) {
                    const rowY = -200 - i * 150; // 从上方开始，间隔更大
                    
                    // 左侧元素
                    const leftX = leftPositions[i % 3];
                    const leftType = ['tree', 'farmhouse'][Math.floor(Math.random() * 2)];
                    this.landscape.push({
                        x: leftX,
                        y: rowY,
                        type: leftType,
                        side: 'left',
                        size: 60 + Math.random() * 120
                    });
                    
                    // 右侧元素
                    const rightX = rightPositions[i % 3];
                    const rightType = ['tree', 'farmhouse'][Math.floor(Math.random() * 2)];
                    this.landscape.push({
                        x: rightX,
                        y: rowY,
                        type: rightType,
                        side: 'right',
                        size: 60 + Math.random() * 120
                    });
                }
            }
            
            initializeClouds() {
                // 游戏开始时创建初始云朵
                for (let i = 0; i < 5; i++) {
                    this.clouds.push({
                        x: Math.random() * this.width,
                        y: 30 + Math.random() * 100,
                        size: 15 + Math.random() * 20,
                        opacity: 0.6 + Math.random() * 0.4
                    });
                }
            }
            
            checkGameOver() {
                if (Math.abs(this.player.sway) >= 60) {
                    this.gameOver();
                }
            }
            
            gameOver() {
                this.gameRunning = false;
                const finalScore = Math.floor(this.distance);
                document.getElementById('finalDistance').textContent = finalScore;
                
                // 更新最高分
                if (finalScore > this.highScore) {
                    this.highScore = finalScore;
                    localStorage.setItem('tightropeHighScore', this.highScore);
                }
                
                document.getElementById('gameOver').style.display = 'block';
            }
            
            updateUI() {
                document.getElementById('distance').textContent = Math.floor(this.distance);
                document.getElementById('sway').textContent = Math.floor(Math.abs(this.player.sway));
                document.getElementById('wind').textContent = (this.wind.force * this.wind.direction).toFixed(2);
                document.getElementById('highScore').textContent = this.highScore;
            }
            
            render() {
                // 清空画布
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // 绘制背景
                this.drawBackground();
                
                // 绘制钢丝
                this.drawTightrope();
                
                // 绘制玩家
                this.drawPlayer();
                
                // 绘制风力指示器
                this.drawWindIndicator();
                
                // 绘制摆幅指示器
                this.drawSwayIndicator();
                
                // 绘制粒子
                this.drawParticles();
                
                // 绘制道具
                this.drawPowerUps();
            }
            
            drawBackground() {
                // 天空渐变
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.5, '#98FB98');
                gradient.addColorStop(1, '#90EE90');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // 云朵（根据风力移动）
                this.drawClouds();
                
                // 田园风景（滚动）
                this.drawScrollingLandscape();
                
                // 装饰气球已删除
            }
            
            drawClouds() {
                this.clouds.forEach(cloud => {
                    this.ctx.save();
                    this.ctx.globalAlpha = cloud.opacity;
                    this.drawCloud(cloud.x, cloud.y, cloud.size);
                    this.ctx.restore();
                });
            }
            
            drawCloud(x, y, size = 20) {
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.arc(x + size * 1.25, y, size * 1.25, 0, Math.PI * 2);
                this.ctx.arc(x + size * 2.5, y, size, 0, Math.PI * 2);
                this.ctx.arc(x + size * 1.25, y - size * 0.75, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            drawScrollingLandscape() {
                // 绘制所有滚动田园风景元素
                this.landscape.forEach(element => {
                    this.drawLandscapeElement(element);
                });
            }
            
            drawLandscapeElement(element) {
                const x = element.x;
                const y = element.y;
                const size = element.size;
                
                switch (element.type) {
                    case 'field':
                        // 农田
                        this.ctx.fillStyle = '#90EE90';
                        this.ctx.fillRect(x, y, size, size * 0.6);
                        // 农田纹理
                        this.ctx.strokeStyle = '#7CCD7C';
                        this.ctx.lineWidth = 1;
                        for (let i = 0; i < 3; i++) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(x, y + i * size * 0.2);
                            this.ctx.lineTo(x + size, y + i * size * 0.2);
                            this.ctx.stroke();
                        }
                        break;
                        
                    case 'tree':
                        // 树木（放大3倍）
                        this.ctx.fillStyle = '#228B22';
                        this.ctx.beginPath();
                        this.ctx.arc(x + size/2, y + size/3, size/2, 0, Math.PI * 2);
                        this.ctx.fill();
                        // 树干（放大3倍）
                        this.ctx.fillStyle = '#8B4513';
                        this.ctx.fillRect(x + size/2 - 9, y + size/2, 18, size/2);
                        // 树木细节
                        this.ctx.fillStyle = '#32CD32';
                        this.ctx.beginPath();
                        this.ctx.arc(x + size/2 - 15, y + size/3 - 10, size/3, 0, Math.PI * 2);
                        this.ctx.arc(x + size/2 + 15, y + size/3 - 10, size/3, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'farmhouse':
                        // 农舍（放大3倍）
                        this.ctx.fillStyle = '#DEB887';
                        this.ctx.fillRect(x, y, size, size * 0.7);
                        // 屋顶（放大3倍）
                        this.ctx.fillStyle = '#8B4513';
                        this.ctx.beginPath();
                        this.ctx.moveTo(x - 15, y);
                        this.ctx.lineTo(x + size/2, y - 45);
                        this.ctx.lineTo(x + size + 15, y);
                        this.ctx.closePath();
                        this.ctx.fill();
                        // 门（放大3倍）
                        this.ctx.fillStyle = '#654321';
                        this.ctx.fillRect(x + size/2 - 12, y + size * 0.4, 24, size * 0.3);
                        // 窗户（放大3倍）
                        this.ctx.fillStyle = '#87CEEB';
                        this.ctx.fillRect(x + size/4, y + size * 0.2, 12, 12);
                        this.ctx.fillRect(x + size * 3/4 - 12, y + size * 0.2, 12, 12);
                        // 窗户框架
                        this.ctx.strokeStyle = '#654321';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(x + size/4, y + size * 0.2, 12, 12);
                        this.ctx.strokeRect(x + size * 3/4 - 12, y + size * 0.2, 12, 12);
                        break;
                        
                    case 'pond':
                        // 池塘
                        this.ctx.fillStyle = '#4682B4';
                        this.ctx.beginPath();
                        this.ctx.ellipse(x + size/2, y + size/2, size/2, size/3, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                        // 水波
                        this.ctx.strokeStyle = '#87CEEB';
                        this.ctx.lineWidth = 1;
                        for (let i = 0; i < 2; i++) {
                            this.ctx.beginPath();
                            this.ctx.ellipse(x + size/2, y + size/2 + i * 5, size/2 - 5, size/3 - 3, 0, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }
                        break;
                        
                    case 'crop':
                        // 庄稼
                        this.ctx.fillStyle = '#9ACD32';
                        for (let i = 0; i < 4; i++) {
                            const cropX = x + i * size/4;
                            this.ctx.fillRect(cropX, y + size * 0.3, 3, size * 0.4);
                        }
                        // 庄稼顶部
                        this.ctx.fillStyle = '#FFD700';
                        for (let i = 0; i < 4; i++) {
                            const cropX = x + i * size/4;
                            this.ctx.beginPath();
                            this.ctx.arc(cropX + 1.5, y + size * 0.2, 2, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        break;
                }
            }
            
            drawBuildings() {
                // 左侧建筑群
                this.drawBuilding(50, this.height/2 - 80, 60, 80, '#A0A0A0');
                this.drawBuilding(120, this.height/2 - 60, 50, 60, '#B0B0B0');
                
                // 右侧建筑
                this.drawBuilding(this.width - 110, this.height/2 - 100, 70, 100, '#C0C0C0');
                
                // 添加窗户
                this.drawWindows(50, this.height/2 - 80, 60, 80);
                this.drawWindows(120, this.height/2 - 60, 50, 60);
                this.drawWindows(this.width - 110, this.height/2 - 100, 70, 100);
            }
            
            drawBuilding(x, y, width, height, color) {
                // 绘制建筑主体（俯瞰视角，更多显示屋顶）
                this.ctx.fillStyle = color;
                this.ctx.fillRect(x, y, width, height);
                
                // 建筑轮廓
                this.ctx.strokeStyle = '#666';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(x, y, width, height);
                
                // 屋顶（俯瞰视角的三角形屋顶）
                this.ctx.fillStyle = '#8B4513';
                this.ctx.beginPath();
                this.ctx.moveTo(x - 8, y);
                this.ctx.lineTo(x + width/2, y - 20);
                this.ctx.lineTo(x + width + 8, y);
                this.ctx.closePath();
                this.ctx.fill();
                
                // 屋顶轮廓
                this.ctx.strokeStyle = '#654321';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(x - 8, y);
                this.ctx.lineTo(x + width/2, y - 20);
                this.ctx.lineTo(x + width + 8, y);
                this.ctx.stroke();
                
                // 屋顶高光
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.beginPath();
                this.ctx.moveTo(x - 6, y - 2);
                this.ctx.lineTo(x + width/2, y - 18);
                this.ctx.lineTo(x + width/2, y - 5);
                this.ctx.closePath();
                this.ctx.fill();
            }
            
            drawWindows(x, y, width, height) {
                // 俯瞰视角的窗户（更小更密集）
                this.ctx.fillStyle = '#87CEEB';
                const windowSize = 4;
                const spacing = 8;
                
                for (let row = 0; row < Math.floor(height / spacing); row++) {
                    for (let col = 0; col < Math.floor(width / spacing); col++) {
                        const wx = x + 5 + col * spacing;
                        const wy = y + 5 + row * spacing;
                        this.ctx.fillRect(wx, wy, windowSize, windowSize);
                        
                        // 窗户框架
                        this.ctx.strokeStyle = '#654321';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(wx, wy, windowSize, windowSize);
                    }
                }
            }
            
            drawBalloons() {
                // 气球位置（跟随玩家移动）
                const balloonX = this.player.x + 80;
                const balloonY = this.height / 2 - 200;
                
                // 气球线
                this.ctx.strokeStyle = '#8B4513';
                this.ctx.lineWidth = 4;
                this.ctx.beginPath();
                this.ctx.moveTo(balloonX, balloonY);
                this.ctx.lineTo(balloonX, balloonY + 40);
                this.ctx.stroke();
                
                // 气球
                const colors = ['#FFD700', '#FF6B6B', '#4ECDC4'];
                for (let i = 0; i < 3; i++) {
                    this.ctx.fillStyle = colors[i];
                    this.ctx.beginPath();
                    this.ctx.arc(balloonX + i * 30 - 30, balloonY - 20, 16, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // 气球高光
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    this.ctx.beginPath();
                    this.ctx.arc(balloonX + i * 30 - 30 - 4, balloonY - 20 - 4, 6, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            drawTightrope() {
                this.ctx.strokeStyle = '#8B4513';
                this.ctx.lineWidth = this.tightrope.thickness;
                this.ctx.beginPath();
                this.ctx.moveTo(this.tightrope.x, 0);
                this.ctx.lineTo(this.tightrope.x, this.height);
                this.ctx.stroke();
            }
            
            drawPlayer() {
                const centerX = this.tightrope.x;
                const centerY = this.height / 2; // 脚的位置（旋转中心）
                const sway = this.player.sway;
                
                // 保存当前状态
                this.ctx.save();
                
                // 移动到旋转中心
                this.ctx.translate(centerX, centerY);
                
                // 根据摆幅旋转
                this.ctx.rotate(sway * Math.PI / 180);
                
                // 绘制身体（相对于旋转中心）
                this.ctx.fillStyle = '#FF6B6B';
                this.ctx.fillRect(-10, -this.player.size/2, 20, this.player.size);
                
                // 绘制头部
                this.ctx.fillStyle = '#FFE66D';
                this.ctx.beginPath();
                this.ctx.arc(0, -this.player.size/2 - 16, 16, 0, Math.PI * 2);
                this.ctx.fill();
                
                // 绘制手臂（平衡杆效果）
                this.ctx.strokeStyle = '#8B4513';
                this.ctx.lineWidth = 6;
                this.ctx.beginPath();
                this.ctx.moveTo(-this.balanceRod.length, 0);
                this.ctx.lineTo(this.balanceRod.length, 0);
                this.ctx.stroke();
                
                // 绘制眼睛
                this.ctx.fillStyle = '#000';
                this.ctx.beginPath();
                this.ctx.arc(-6, -this.player.size/2 - 20, 2, 0, Math.PI * 2);
                this.ctx.arc(6, -this.player.size/2 - 20, 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                // 绘制脚部（与钢丝接触的点）
                this.ctx.fillStyle = '#8B4513';
                this.ctx.beginPath();
                this.ctx.arc(0, this.player.size/2, 6, 0, Math.PI * 2);
                this.ctx.fill();
                
                // 恢复状态
                this.ctx.restore();
                
                // 更新玩家实际位置（用于气球跟随等）
                this.player.x = centerX;
                this.player.y = centerY;
            }
            
            drawWindIndicator() {
                const x = this.width - 100;
                const y = 50;
                const windForce = this.wind.force * this.wind.direction;
                
                // 背景
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.fillRect(x - 10, y - 20, 80, 40);
                
                // 风力条
                this.ctx.fillStyle = windForce > 0 ? '#FF6B6B' : '#4ECDC4';
                const barWidth = Math.abs(windForce) * 60;
                this.ctx.fillRect(x, y - 5, barWidth, 10);
                
                // 中心线
                this.ctx.strokeStyle = '#FFF';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(x + 30, y - 10);
                this.ctx.lineTo(x + 30, y + 10);
                this.ctx.stroke();
            }
            
            drawSwayIndicator() {
                const x = 50;
                const y = this.height - 100;
                const sway = this.player.sway;
                
                // 背景圆
                this.ctx.strokeStyle = '#FFF';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 30, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // 危险区域（左右两侧）
                this.ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                this.ctx.beginPath();
                this.ctx.arc(x, y, 30, Math.PI * 0.25, Math.PI * 0.75);
                this.ctx.arc(x, y, 30, Math.PI * 1.25, Math.PI * 1.75);
                this.ctx.fill();
                
                // 指针（水平方向显示摆幅）
                this.ctx.strokeStyle = '#FF0';
                this.ctx.lineWidth = 4;
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(
                    x + Math.sin(sway * Math.PI / 180) * 25,
                    y
                );
                this.ctx.stroke();
            }
            
            drawParticles() {
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.fillStyle = '#FFD700';
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
            }
            
            drawPowerUps() {
                this.powerUps.forEach(powerUp => {
                    this.drawPowerUp(powerUp);
                });
            }
            
            drawPowerUp(powerUp) {
                const x = powerUp.x;
                const y = powerUp.y;
                const size = powerUp.size;
                
                // 根据道具类型确定气球颜色
                let balloonColor = '#FFB6C1'; // 默认粉色
                let boxColor = '#FFFFFF';
                let textColor = '#000000';
                let text = '';
                
                if (powerUp.type === 'explosion') {
                    balloonColor = '#000000'; // 黑色气球 - 坏道具
                    text = '爆炸';
                } else if (powerUp.type === 'speed') {
                    balloonColor = '#FF0000'; // 红色气球 - 好道具
                    text = '加速';
                } else if (powerUp.type === 'balance') {
                    balloonColor = '#00FF00'; // 绿色气球 - 好道具
                    text = '平衡';
                } else if (powerUp.type === 'slow') {
                    balloonColor = '#0080FF'; // 蓝色气球 - 坏道具
                    text = '减速';
                } else if (powerUp.type === 'unbalance') {
                    balloonColor = '#FFFF00'; // 黄色气球 - 坏道具
                    text = '失衡';
                }
                
                // 绘制气球（放大3倍）
                this.ctx.fillStyle = balloonColor;
                this.ctx.beginPath();
                this.ctx.arc(x, y - 15, 24, 0, Math.PI * 2); // 从8放大到24
                this.ctx.fill();
                
                // 气球高光
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                this.ctx.beginPath();
                this.ctx.arc(x - 6, y - 19, 6, 0, Math.PI * 2); // 高光也放大
                this.ctx.fill();
                
                // 气球线
                this.ctx.strokeStyle = '#8B4513';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(x, y - 7);
                this.ctx.lineTo(x, y + 5);
                this.ctx.stroke();
                
                // 绘制道具方块
                this.ctx.fillStyle = boxColor;
                this.ctx.fillRect(x - size/2, y + 5, size, size);
                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(x - size/2, y + 5, size, size);
                
                // 绘制道具文字
                this.ctx.fillStyle = textColor;
                this.ctx.font = 'bold 12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(text, x, y + 18);
            }
            
            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // 启动游戏
        window.addEventListener('load', () => {
            new TightropeGame();
        });
    </script>
</body>
</html>
